//! Linear GraphQL query types generated by cynic.
//!
//! This crate contains all `QueryFragment`, `InputObject`, and `Enum` derives
//! that trigger expensive proc-macro expansion against the 36k-line Linear schema.
//! Isolating them here prevents recompilation when editing handler/CLI code.

use cynic::QueryFragment;
use serde::Serialize;

// Re-export schema and scalar types so downstream crates can use them.
pub use linear_schema::{DateTime, TimelessDate, schema};

/// User information for authentication
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "User", schema = "linear")]
pub struct UserInfo {
    pub id: cynic::Id,
    #[cynic(rename = "displayName")]
    pub name: String,
    pub email: String,
}

/// Viewer query for authentication
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "Query", schema = "linear")]
pub struct ViewerQuery {
    pub viewer: UserInfo,
}

/// User information for issues
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "User", schema = "linear")]
pub struct IssueUser {
    pub id: cynic::Id,
    pub name: String,
    pub email: String,
}

/// Project information for issues (minimal fields)
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "Project", schema = "linear")]
pub struct IssueProject {
    pub id: cynic::Id,
    pub name: String,
    #[cynic(rename = "slugId")]
    pub slug_id: String,
}

/// Workflow state information
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "WorkflowState", schema = "linear")]
pub struct WorkflowState {
    pub id: cynic::Id,
    pub name: String,
}

/// Issue information
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Issue", schema = "linear")]
pub struct IssueNode {
    pub id: cynic::Id,
    pub identifier: String,
    pub title: String,
    pub description: Option<String>,
    pub state: WorkflowState,
    pub priority: f64,
    pub assignee: Option<IssueUser>,
    pub creator: Option<IssueUser>,
    pub project: Option<IssueProject>,
    #[cynic(rename = "createdAt")]
    pub created_at: DateTime,
    #[cynic(rename = "updatedAt")]
    pub updated_at: DateTime,
    pub url: String,
}

/// Issue query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueQueryVariables {
    pub id: String,
}

/// Issue query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "IssueQueryVariables"
)]
pub struct IssueQuery {
    #[arguments(id: $id)]
    pub issue: Option<IssueNode>,
}

/// Issue connection for paginated results
#[derive(Debug, Clone, QueryFragment)]
#[cynic(graphql_type = "IssueConnection", schema = "linear")]
pub struct IssueConnection {
    pub nodes: Vec<IssueNode>,
}

/// Issues query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssuesQueryVariables {
    pub first: Option<i32>,
    pub filter: Option<IssueFilterInput>,
}

/// Issue filter input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "IssueFilter")]
pub struct IssueFilterInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub assignee: Option<NullableUserFilterInput>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub project: Option<NullableProjectFilterInput>,
}

/// Nullable user filter input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "NullableUserFilter")]
pub struct NullableUserFilterInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub id: Option<IDComparatorInput>,
    #[cynic(rename = "isMe", skip_serializing_if = "Option::is_none")]
    pub is_me: Option<BooleanComparatorInput>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub email: Option<StringComparatorInput>,
}

/// ID comparator input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "IDComparator")]
pub struct IDComparatorInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub eq: Option<cynic::Id>,
}

/// String comparator input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "StringComparator")]
pub struct StringComparatorInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub eq: Option<String>,
}

/// Boolean comparator input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "BooleanComparator")]
pub struct BooleanComparatorInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub eq: Option<bool>,
}

/// Nullable project filter input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "NullableProjectFilter")]
pub struct NullableProjectFilterInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub id: Option<IDComparatorInput>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub name: Option<StringComparatorInput>,
    #[cynic(rename = "slugId", skip_serializing_if = "Option::is_none")]
    pub slug_id: Option<StringComparatorInput>,
}

/// Issues query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "IssuesQueryVariables"
)]
pub struct IssuesQuery {
    #[arguments(first: $first, filter: $filter)]
    pub issues: IssueConnection,
}

/// Issue create input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "IssueCreateInput")]
pub struct IssueCreateInput {
    #[cynic(rename = "teamId")]
    pub team_id: String,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[cynic(rename = "assigneeId", skip_serializing_if = "Option::is_none")]
    pub assignee_id: Option<String>,
    #[cynic(rename = "projectId", skip_serializing_if = "Option::is_none")]
    pub project_id: Option<String>,
    #[cynic(rename = "stateId", skip_serializing_if = "Option::is_none")]
    pub state_id: Option<String>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
}

/// Issue create mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueCreateMutationVariables {
    pub input: IssueCreateInput,
}

/// Payload returned by issue create/update mutation
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "IssuePayload", schema = "linear")]
pub struct IssuePayload {
    pub issue: Option<IssueNode>,
}

/// Issue create mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "IssueCreateMutationVariables"
)]
pub struct IssueCreateMutation {
    #[arguments(input: $input)]
    #[cynic(rename = "issueCreate")]
    pub issue_create: IssuePayload,
}

/// Issue update input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "IssueUpdateInput")]
pub struct IssueUpdateInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub title: Option<String>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[cynic(rename = "assigneeId", skip_serializing_if = "Option::is_none")]
    pub assignee_id: Option<String>,
    #[cynic(rename = "projectId", skip_serializing_if = "Option::is_none")]
    pub project_id: Option<String>,
    #[cynic(rename = "stateId", skip_serializing_if = "Option::is_none")]
    pub state_id: Option<String>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub priority: Option<i32>,
}

/// Issue update mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueUpdateMutationVariables {
    pub id: String,
    pub input: IssueUpdateInput,
}

/// Issue update mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "IssueUpdateMutationVariables"
)]
pub struct IssueUpdateMutation {
    #[arguments(id: $id, input: $input)]
    #[cynic(rename = "issueUpdate")]
    pub issue_update: IssuePayload,
}

/// Payload returned by issue archive/unarchive mutations
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "IssueArchivePayload", schema = "linear")]
pub struct IssueArchivePayload {
    pub entity: Option<IssueNode>,
}

/// Issue archive mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueArchiveMutationVariables {
    pub id: String,
    pub trash: Option<bool>,
}

/// Issue archive mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "IssueArchiveMutationVariables"
)]
pub struct IssueArchiveMutation {
    #[arguments(id: $id, trash: $trash)]
    #[cynic(rename = "issueArchive")]
    pub issue_archive: IssueArchivePayload,
}

/// Issue unarchive mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueUnarchiveMutationVariables {
    pub id: String,
}

/// Issue unarchive mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "IssueUnarchiveMutationVariables"
)]
pub struct IssueUnarchiveMutation {
    #[arguments(id: $id)]
    #[cynic(rename = "issueUnarchive")]
    pub issue_unarchive: IssueArchivePayload,
}

/// Issue relation type enum
#[derive(cynic::Enum, Debug, Clone, Copy, PartialEq, Eq)]
#[cynic(schema = "linear", graphql_type = "IssueRelationType")]
pub enum IssueRelationType {
    #[cynic(rename = "blocks")]
    Blocks,
    #[cynic(rename = "duplicate")]
    Duplicate,
    #[cynic(rename = "related")]
    Related,
    #[cynic(rename = "similar")]
    Similar,
}

/// Issue relation create input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "IssueRelationCreateInput")]
pub struct IssueRelationCreateInput {
    #[cynic(rename = "issueId")]
    pub issue_id: String,
    #[cynic(rename = "relatedIssueId")]
    pub related_issue_id: String,
    #[cynic(rename = "type")]
    pub relation_type: IssueRelationType,
}

/// Issue relation create mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueRelationCreateMutationVariables {
    pub input: IssueRelationCreateInput,
}

/// Issue relation node returned by mutation payload.
#[derive(Debug, Clone, QueryFragment)]
#[cynic(graphql_type = "IssueRelation", schema = "linear")]
pub struct IssueRelationNode {
    pub issue: IssueNode,
}

/// Payload returned by issue relation mutations
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "IssueRelationPayload", schema = "linear")]
pub struct IssueRelationPayload {
    #[cynic(rename = "issueRelation")]
    pub issue_relation: IssueRelationNode,
}

/// Issue relation create mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "IssueRelationCreateMutationVariables"
)]
pub struct IssueRelationCreateMutation {
    #[arguments(input: $input)]
    #[cynic(rename = "issueRelationCreate")]
    pub issue_relation_create: IssueRelationPayload,
}

/// Team information
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Team", schema = "linear")]
pub struct TeamNode {
    pub id: cynic::Id,
    pub key: String,
    pub name: String,
    pub description: Option<String>,
    pub color: Option<String>,
    pub icon: Option<String>,
    pub private: bool,
    #[cynic(rename = "createdAt")]
    pub created_at: DateTime,
}

/// Team query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct TeamQueryVariables {
    pub id: String,
}

/// Team query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "TeamQueryVariables"
)]
pub struct TeamQuery {
    #[arguments(id: $id)]
    pub team: TeamNode,
}

/// Team connection for paginated results
#[derive(Debug, Clone, QueryFragment)]
#[cynic(graphql_type = "TeamConnection", schema = "linear")]
pub struct TeamConnection {
    pub nodes: Vec<TeamNode>,
}

/// Teams query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct TeamsQueryVariables {
    pub first: Option<i32>,
}

/// Teams query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "TeamsQueryVariables"
)]
pub struct TeamsQuery {
    #[arguments(first: $first)]
    pub teams: TeamConnection,
}

/// Project lead user information
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "User", schema = "linear")]
pub struct ProjectLead {
    pub id: cynic::Id,
    pub name: String,
}

/// Project status type enum
#[derive(cynic::Enum, Debug, Clone, Copy, PartialEq, Eq)]
#[cynic(schema = "linear", graphql_type = "ProjectStatusType")]
pub enum ProjectStatusType {
    #[cynic(rename = "backlog")]
    Backlog,
    #[cynic(rename = "planned")]
    Planned,
    #[cynic(rename = "started")]
    Started,
    #[cynic(rename = "paused")]
    Paused,
    #[cynic(rename = "completed")]
    Completed,
    #[cynic(rename = "canceled")]
    Canceled,
}

/// Project status information
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "ProjectStatus", schema = "linear")]
pub struct ProjectStatus {
    pub name: String,
    #[cynic(rename = "type")]
    pub status_type: ProjectStatusType,
    pub color: String,
}

/// Project information
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Project", schema = "linear")]
pub struct ProjectNode {
    pub id: cynic::Id,
    pub name: String,
    pub description: String,
    pub content: Option<String>,
    #[cynic(rename = "slugId")]
    pub slug_id: String,
    pub url: String,
    pub color: String,
    pub icon: Option<String>,
    pub status: ProjectStatus,
    pub progress: f64,
    pub priority: i32,
    #[cynic(rename = "priorityLabel")]
    pub priority_label: String,
    #[cynic(rename = "startDate")]
    pub start_date: Option<TimelessDate>,
    #[cynic(rename = "targetDate")]
    pub target_date: Option<TimelessDate>,
    pub lead: Option<ProjectLead>,
    #[cynic(rename = "createdAt")]
    pub created_at: DateTime,
    #[cynic(rename = "updatedAt")]
    pub updated_at: DateTime,
}

/// Project query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct ProjectQueryVariables {
    pub id: String,
}

/// Project query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "ProjectQueryVariables"
)]
pub struct ProjectQuery {
    #[arguments(id: $id)]
    pub project: ProjectNode,
}

/// Project connection for paginated results
#[derive(Debug, Clone, QueryFragment)]
#[cynic(graphql_type = "ProjectConnection", schema = "linear")]
pub struct ProjectConnection {
    pub nodes: Vec<ProjectNode>,
}

/// Projects query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct ProjectsQueryVariables {
    pub first: Option<i32>,
}

/// Projects query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "ProjectsQueryVariables"
)]
pub struct ProjectsQuery {
    #[arguments(first: $first)]
    pub projects: ProjectConnection,
}

/// Cycle team information
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "Team", schema = "linear")]
pub struct CycleTeam {
    pub name: String,
    pub key: String,
}

/// Cycle information
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Cycle", schema = "linear")]
pub struct CycleNode {
    pub id: cynic::Id,
    pub name: Option<String>,
    pub number: f64,
    pub description: Option<String>,
    #[cynic(rename = "startsAt")]
    pub starts_at: DateTime,
    #[cynic(rename = "endsAt")]
    pub ends_at: DateTime,
    #[cynic(rename = "createdAt")]
    pub created_at: DateTime,
    #[cynic(rename = "completedAt")]
    pub completed_at: Option<DateTime>,
    pub progress: f64,
    #[cynic(rename = "isActive")]
    pub is_active: bool,
    #[cynic(rename = "isFuture")]
    pub is_future: bool,
    #[cynic(rename = "isNext")]
    pub is_next: bool,
    #[cynic(rename = "isPast")]
    pub is_past: bool,
    #[cynic(rename = "isPrevious")]
    pub is_previous: bool,
    pub team: CycleTeam,
}

/// Cycle query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct CycleQueryVariables {
    pub id: String,
}

/// Cycle query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "CycleQueryVariables"
)]
pub struct CycleQuery {
    #[arguments(id: $id)]
    pub cycle: CycleNode,
}

/// Cycle connection for paginated results
#[derive(Debug, Clone, QueryFragment)]
#[cynic(graphql_type = "CycleConnection", schema = "linear")]
pub struct CycleConnection {
    pub nodes: Vec<CycleNode>,
}

/// Cycles query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct CyclesQueryVariables {
    pub first: Option<i32>,
}

/// Cycles query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "CyclesQueryVariables"
)]
pub struct CyclesQuery {
    #[arguments(first: $first)]
    pub cycles: CycleConnection,
}

/// User information for comments
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "User", schema = "linear")]
pub struct CommentUser {
    pub name: String,
    pub email: String,
}

/// Issue information for comment context
#[derive(Debug, Clone, PartialEq, Eq, Serialize, QueryFragment)]
#[cynic(graphql_type = "Issue", schema = "linear")]
pub struct CommentIssue {
    pub identifier: String,
}

/// Comment information
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Comment", schema = "linear")]
pub struct CommentNode {
    pub id: cynic::Id,
    pub body: String,
    pub user: Option<CommentUser>,
    #[cynic(rename = "createdAt")]
    pub created_at: DateTime,
    #[cynic(rename = "updatedAt")]
    pub updated_at: DateTime,
    #[cynic(rename = "editedAt")]
    pub edited_at: Option<DateTime>,
    pub issue: Option<CommentIssue>,
}

/// Comment connection for paginated results
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "CommentConnection", schema = "linear")]
pub struct CommentConnection {
    pub nodes: Vec<CommentNode>,
}

/// Issue comments query - queries comments for a specific issue
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(
    graphql_type = "Issue",
    schema = "linear",
    variables = "IssueCommentsQueryVariables"
)]
pub struct IssueWithComments {
    pub identifier: String,
    #[arguments(first: $first)]
    pub comments: CommentConnection,
}

/// Issue comments query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueCommentsQueryVariables {
    pub id: String,
    pub first: Option<i32>,
}

/// Issue comments query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "IssueCommentsQueryVariables"
)]
pub struct IssueCommentsQuery {
    #[arguments(id: $id)]
    pub issue: Option<IssueWithComments>,
}

/// Comment create input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "CommentCreateInput")]
pub struct CommentCreateInput {
    #[cynic(rename = "issueId", skip_serializing_if = "Option::is_none")]
    pub issue_id: Option<String>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub body: Option<String>,
}

/// Comment create mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct CommentCreateMutationVariables {
    pub input: CommentCreateInput,
}

/// Comment payload returned by comment mutations
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "CommentPayload", schema = "linear")]
pub struct CommentPayload {
    pub comment: CommentNode,
}

/// Comment create mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "CommentCreateMutationVariables"
)]
pub struct CommentCreateMutation {
    #[arguments(input: $input)]
    #[cynic(rename = "commentCreate")]
    pub comment_create: CommentPayload,
}

// ── Discovery queries (states, labels, users) ──

/// Team filter input for scoping queries to a specific team
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "TeamFilter")]
pub struct TeamFilterInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub key: Option<StringComparatorInput>,
}

/// Workflow state filter input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "WorkflowStateFilter")]
pub struct WorkflowStateFilterInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub team: Option<TeamFilterInput>,
}

/// Workflow state node with full details
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "WorkflowState", schema = "linear")]
pub struct WorkflowStateNode {
    pub id: cynic::Id,
    pub name: String,
    #[cynic(rename = "type")]
    pub state_type: String,
    pub color: String,
    pub position: f64,
    pub description: Option<String>,
    pub team: WorkflowStateTeam,
}

/// Team info embedded in workflow state
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Team", schema = "linear")]
pub struct WorkflowStateTeam {
    pub name: String,
}

/// Workflow state connection
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "WorkflowStateConnection", schema = "linear")]
pub struct WorkflowStateConnection {
    pub nodes: Vec<WorkflowStateNode>,
}

/// WorkflowStates query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct WorkflowStatesQueryVariables {
    pub first: Option<i32>,
    #[cynic(rename = "teamId", skip_serializing_if = "Option::is_none")]
    pub team_id: Option<String>,
}

/// WorkflowStates query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "WorkflowStatesQueryVariables"
)]
pub struct WorkflowStatesQuery {
    #[arguments(
        first: $first,
        filter: { team: { key: { eq: $team_id } } }
    )]
    #[cynic(rename = "workflowStates")]
    pub workflow_states: WorkflowStateConnection,
}

/// Nullable team filter input (for labels which use NullableTeamFilter)
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "NullableTeamFilter")]
pub struct NullableTeamFilterInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub key: Option<StringComparatorInput>,
}

/// Issue label filter input
#[derive(cynic::InputObject, Debug, Clone)]
#[cynic(schema = "linear", graphql_type = "IssueLabelFilter")]
pub struct IssueLabelFilterInput {
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub team: Option<NullableTeamFilterInput>,
}

/// Issue label node with full details
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "IssueLabel", schema = "linear")]
pub struct IssueLabelNode {
    pub id: cynic::Id,
    pub name: String,
    pub color: String,
    pub description: Option<String>,
    #[cynic(rename = "isGroup")]
    pub is_group: bool,
    pub parent: Option<IssueLabelParent>,
}

/// Parent label info
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "IssueLabel", schema = "linear")]
pub struct IssueLabelParent {
    pub name: String,
}

/// Issue label connection
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "IssueLabelConnection", schema = "linear")]
pub struct IssueLabelConnection {
    pub nodes: Vec<IssueLabelNode>,
}

/// IssueLabels query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueLabelsQueryVariables {
    pub first: Option<i32>,
    #[cynic(rename = "teamId", skip_serializing_if = "Option::is_none")]
    pub team_id: Option<String>,
}

/// IssueLabels query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "IssueLabelsQueryVariables"
)]
pub struct IssueLabelsQuery {
    #[arguments(
        first: $first,
        filter: { team: { key: { eq: $team_id } } }
    )]
    #[cynic(rename = "issueLabels")]
    pub issue_labels: IssueLabelConnection,
}

/// User node with full details
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "User", schema = "linear")]
pub struct UserNode {
    pub id: cynic::Id,
    pub name: String,
    #[cynic(rename = "displayName")]
    pub display_name: String,
    pub email: String,
    pub active: bool,
    pub admin: bool,
    pub guest: bool,
}

/// User connection
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "UserConnection", schema = "linear")]
pub struct UserConnection {
    pub nodes: Vec<UserNode>,
}

/// Users query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct UsersQueryVariables {
    pub first: Option<i32>,
}

/// Users query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "UsersQueryVariables"
)]
pub struct UsersQuery {
    #[arguments(first: $first)]
    pub users: UserConnection,
}

// ── SearchIssues ──

/// Search issue result node (same fields as Issue, different GraphQL type)
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "IssueSearchResult", schema = "linear")]
pub struct SearchIssueNode {
    pub id: cynic::Id,
    pub identifier: String,
    pub title: String,
    pub description: Option<String>,
    pub state: WorkflowState,
    pub priority: f64,
    pub assignee: Option<IssueUser>,
    pub creator: Option<IssueUser>,
    pub project: Option<IssueProject>,
    #[cynic(rename = "createdAt")]
    pub created_at: DateTime,
    #[cynic(rename = "updatedAt")]
    pub updated_at: DateTime,
    pub url: String,
}

/// Search results payload
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "IssueSearchPayload", schema = "linear")]
pub struct IssueSearchPayload {
    pub nodes: Vec<SearchIssueNode>,
}

/// SearchIssues query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct SearchIssuesQueryVariables {
    pub term: String,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub first: Option<i32>,
    #[cynic(rename = "teamId", skip_serializing_if = "Option::is_none")]
    pub team_id: Option<String>,
    #[cynic(rename = "includeComments", skip_serializing_if = "Option::is_none")]
    pub include_comments: Option<bool>,
}

/// SearchIssues query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "SearchIssuesQueryVariables"
)]
pub struct SearchIssuesQuery {
    #[arguments(
        term: $term,
        first: $first,
        teamId: $team_id,
        includeComments: $include_comments
    )]
    #[cynic(rename = "searchIssues")]
    pub search_issues: IssueSearchPayload,
}

// ── Delete mutations ──

/// Issue delete mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct IssueDeleteMutationVariables {
    pub id: String,
    #[cynic(rename = "permanentlyDelete", skip_serializing_if = "Option::is_none")]
    pub permanently_delete: Option<bool>,
}

/// Issue delete mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "IssueDeleteMutationVariables"
)]
pub struct IssueDeleteMutation {
    #[arguments(id: $id, permanentlyDelete: $permanently_delete)]
    #[cynic(rename = "issueDelete")]
    pub issue_delete: IssueArchivePayload,
}

/// Delete payload (for comment delete)
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "DeletePayload", schema = "linear")]
pub struct DeletePayload {
    #[cynic(rename = "entityId")]
    pub entity_id: String,
    pub success: bool,
}

/// Comment delete mutation variables
#[derive(cynic::QueryVariables, Debug)]
pub struct CommentDeleteMutationVariables {
    pub id: String,
}

/// Comment delete mutation
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Mutation",
    schema = "linear",
    variables = "CommentDeleteMutationVariables"
)]
pub struct CommentDeleteMutation {
    #[arguments(id: $id)]
    #[cynic(rename = "commentDelete")]
    pub comment_delete: DeletePayload,
}

// ── Semantic Search ──

/// Semantic search result type enum
#[derive(cynic::Enum, Debug, Clone, Copy)]
#[cynic(
    schema = "linear",
    graphql_type = "SemanticSearchResultType",
    rename_all = "camelCase"
)]
pub enum SemanticSearchResultType {
    Document,
    Initiative,
    Issue,
    Project,
}

/// Issue info within a semantic search result
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Issue", schema = "linear")]
pub struct SemanticIssueInfo {
    pub identifier: String,
    pub title: String,
    pub url: String,
}

/// Project info within a semantic search result
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Project", schema = "linear")]
pub struct SemanticProjectInfo {
    pub name: String,
    pub url: String,
}

/// Document info within a semantic search result
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Document", schema = "linear")]
pub struct SemanticDocumentInfo {
    pub title: String,
}

/// Initiative info within a semantic search result
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "Initiative", schema = "linear")]
pub struct SemanticInitiativeInfo {
    pub name: String,
}

/// Semantic search result node
#[derive(Debug, Clone, Serialize, QueryFragment)]
#[cynic(graphql_type = "SemanticSearchResult", schema = "linear")]
pub struct SemanticSearchResultNode {
    pub id: cynic::Id,
    #[cynic(rename = "type")]
    pub result_type: SemanticSearchResultType,
    pub issue: Option<SemanticIssueInfo>,
    pub project: Option<SemanticProjectInfo>,
    pub document: Option<SemanticDocumentInfo>,
    pub initiative: Option<SemanticInitiativeInfo>,
}

/// Semantic search payload
#[derive(Debug, QueryFragment)]
#[cynic(graphql_type = "SemanticSearchPayload", schema = "linear")]
pub struct SemanticSearchPayloadResult {
    pub results: Vec<SemanticSearchResultNode>,
}

/// Semantic search query variables
#[derive(cynic::QueryVariables, Debug)]
pub struct SemanticSearchQueryVariables {
    pub query: String,
    #[cynic(rename = "maxResults", skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i32>,
    #[cynic(skip_serializing_if = "Option::is_none")]
    pub types: Option<Vec<SemanticSearchResultType>>,
}

/// Semantic search query
#[derive(Debug, QueryFragment)]
#[cynic(
    graphql_type = "Query",
    schema = "linear",
    variables = "SemanticSearchQueryVariables"
)]
pub struct SemanticSearchQuery {
    #[arguments(query: $query, maxResults: $max_results, types: $types)]
    #[cynic(rename = "semanticSearch")]
    pub semantic_search: SemanticSearchPayloadResult,
}
